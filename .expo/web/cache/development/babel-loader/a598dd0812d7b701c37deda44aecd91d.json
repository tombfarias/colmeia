{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.append = append;\nexports.appendTransform = appendTransform;\nexports.identity = void 0;\nexports.reset = reset;\nexports.toArray = toArray;\nvar DEG_TO_RAD = Math.PI / 180;\nvar identity = [1, 0, 0, 1, 0, 0];\nexports.identity = identity;\nvar a = 1;\nvar b = 0;\nvar c = 0;\nvar d = 1;\nvar tx = 0;\nvar ty = 0;\nvar hasInitialState = true;\n\nfunction reset() {\n  if (hasInitialState) {\n    return;\n  }\n\n  a = d = 1;\n  b = c = tx = ty = 0;\n  hasInitialState = true;\n}\n\nfunction toArray() {\n  if (hasInitialState) {\n    return identity;\n  }\n\n  return [a, b, c, d, tx, ty];\n}\n\nfunction append(a2, b2, c2, d2, tx2, ty2) {\n  var change = a2 !== 1 || b2 !== 0 || c2 !== 0 || d2 !== 1;\n  var translate = tx2 !== 0 || ty2 !== 0;\n\n  if (!change && !translate) {\n    return;\n  }\n\n  if (hasInitialState) {\n    hasInitialState = false;\n    a = a2;\n    b = b2;\n    c = c2;\n    d = d2;\n    tx = tx2;\n    ty = ty2;\n    return;\n  }\n\n  var a1 = a;\n  var b1 = b;\n  var c1 = c;\n  var d1 = d;\n\n  if (change) {\n    a = a1 * a2 + c1 * b2;\n    b = b1 * a2 + d1 * b2;\n    c = a1 * c2 + c1 * d2;\n    d = b1 * c2 + d1 * d2;\n  }\n\n  if (translate) {\n    tx = a1 * tx2 + c1 * ty2 + tx;\n    ty = b1 * tx2 + d1 * ty2 + ty;\n  }\n}\n\nfunction appendTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n  if (x === 0 && y === 0 && scaleX === 1 && scaleY === 1 && rotation === 0 && skewX === 0 && skewY === 0 && regX === 0 && regY === 0) {\n    return;\n  }\n\n  var cos, sin;\n\n  if (rotation % 360) {\n    var r = rotation * DEG_TO_RAD;\n    cos = Math.cos(r);\n    sin = Math.sin(r);\n  } else {\n    cos = 1;\n    sin = 0;\n  }\n\n  var a2 = cos * scaleX;\n  var b2 = sin * scaleX;\n  var c2 = -sin * scaleY;\n  var d2 = cos * scaleY;\n\n  if (skewX || skewY) {\n    var b1 = Math.tan(skewY * DEG_TO_RAD);\n    var c1 = Math.tan(skewX * DEG_TO_RAD);\n    append(a2 + c1 * b2, b1 * a2 + b2, c2 + c1 * d2, b1 * c2 + d2, x, y);\n  } else {\n    append(a2, b2, c2, d2, x, y);\n  }\n\n  if (regX || regY) {\n    tx -= regX * a + regY * c;\n    ty -= regX * b + regY * d;\n    hasInitialState = false;\n  }\n}","map":{"version":3,"sources":["Matrix2D.ts"],"names":["DEG_TO_RAD","Math","PI","identity","a","b","c","d","tx","ty","hasInitialState","reset","toArray","append","a2","b2","c2","d2","tx2","ty2","change","translate","a1","b1","c1","d1","appendTransform","x","y","scaleX","scaleY","rotation","skewX","skewY","regX","regY","cos","sin","r","tan"],"mappings":"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","sourcesContent":["/**\n * based on\n * https://github.com/CreateJS/EaselJS/blob/631cdffb85eff9413dab43b4676f059b4232d291/src/easeljs/geom/Matrix2D.js\n */\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport const identity: [number, number, number, number, number, number] = [\n  1, 0, 0, 1, 0, 0,\n];\n\nlet a = 1;\nlet b = 0;\nlet c = 0;\nlet d = 1;\nlet tx = 0;\nlet ty = 0;\nlet hasInitialState = true;\n\n/**\n * Represents an affine transformation matrix, and provides tools for concatenating transforms.\n *\n * This matrix can be visualized as:\n *\n * \t[ a  c  tx\n * \t  b  d  ty\n * \t  0  0  1  ]\n *\n * Note the locations of b and c.\n **/\n\n/**\n * Reset current matrix to an identity matrix.\n * @method reset\n **/\nexport function reset() {\n  if (hasInitialState) {\n    return;\n  }\n  a = d = 1;\n  b = c = tx = ty = 0;\n  hasInitialState = true;\n}\n\n/**\n * Returns an array with current matrix values.\n * @method toArray\n * @return {Array} an array with current matrix values.\n **/\nexport function toArray(): [number, number, number, number, number, number] {\n  if (hasInitialState) {\n    return identity;\n  }\n  return [a, b, c, d, tx, ty];\n}\n\n/**\n * Appends the specified matrix properties to this matrix. All parameters are required.\n * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n * @method append\n * @param {Number} a2\n * @param {Number} b2\n * @param {Number} c2\n * @param {Number} d2\n * @param {Number} tx2\n * @param {Number} ty2\n **/\nexport function append(\n  a2: number,\n  b2: number,\n  c2: number,\n  d2: number,\n  tx2: number,\n  ty2: number,\n) {\n  const change = a2 !== 1 || b2 !== 0 || c2 !== 0 || d2 !== 1;\n  const translate = tx2 !== 0 || ty2 !== 0;\n  if (!change && !translate) {\n    return;\n  }\n  if (hasInitialState) {\n    hasInitialState = false;\n    a = a2;\n    b = b2;\n    c = c2;\n    d = d2;\n    tx = tx2;\n    ty = ty2;\n    return;\n  }\n  const a1 = a;\n  const b1 = b;\n  const c1 = c;\n  const d1 = d;\n  if (change) {\n    a = a1 * a2 + c1 * b2;\n    b = b1 * a2 + d1 * b2;\n    c = a1 * c2 + c1 * d2;\n    d = b1 * c2 + d1 * d2;\n  }\n  if (translate) {\n    tx = a1 * tx2 + c1 * ty2 + tx;\n    ty = b1 * tx2 + d1 * ty2 + ty;\n  }\n}\n\n/**\n * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n * For example, you can use this to generate a matrix representing the transformations of a display object:\n *\n * \treset();\n * \tappendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n * \tvar matrix = toArray()\n *\n * @method appendTransform\n * @param {Number} x\n * @param {Number} y\n * @param {Number} scaleX\n * @param {Number} scaleY\n * @param {Number} rotation\n * @param {Number} skewX\n * @param {Number} skewY\n * @param {Number} regX Optional.\n * @param {Number} regY Optional.\n **/\nexport function appendTransform(\n  x: number,\n  y: number,\n  scaleX: number,\n  scaleY: number,\n  rotation: number,\n  skewX: number,\n  skewY: number,\n  regX: number,\n  regY: number,\n) {\n  if (\n    x === 0 &&\n    y === 0 &&\n    scaleX === 1 &&\n    scaleY === 1 &&\n    rotation === 0 &&\n    skewX === 0 &&\n    skewY === 0 &&\n    regX === 0 &&\n    regY === 0\n  ) {\n    return;\n  }\n  let cos, sin;\n  if (rotation % 360) {\n    const r = rotation * DEG_TO_RAD;\n    cos = Math.cos(r);\n    sin = Math.sin(r);\n  } else {\n    cos = 1;\n    sin = 0;\n  }\n\n  const a2 = cos * scaleX;\n  const b2 = sin * scaleX;\n  const c2 = -sin * scaleY;\n  const d2 = cos * scaleY;\n\n  if (skewX || skewY) {\n    const b1 = Math.tan(skewY * DEG_TO_RAD);\n    const c1 = Math.tan(skewX * DEG_TO_RAD);\n    append(a2 + c1 * b2, b1 * a2 + b2, c2 + c1 * d2, b1 * c2 + d2, x, y);\n  } else {\n    append(a2, b2, c2, d2, x, y);\n  }\n\n  if (regX || regY) {\n    // append the registration offset:\n    tx -= regX * a + regY * c;\n    ty -= regX * b + regY * d;\n    hasInitialState = false;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}